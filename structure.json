{
  "public": {
    "js": {
      "calculo.js": "export function calcularGanancia() {\r\n  let gasto = 0; // Reiniciamos el gasto\r\n\r\n  // Obtener la cantidad de objetos a fabricar\r\n  const cantidadFabricarInput = document.getElementById(\"cantidadFabricar\");\r\n  const cantidadFabricar = cantidadFabricarInput ? parseInt(cantidadFabricarInput.value) || 1 : 1;\r\n\r\n  console.log(`[DEBUG] Cantidad a fabricar: ${cantidadFabricar}`);\r\n\r\n  // Obtener los ingredientes desde el dataset\r\n  const ingredientesElement = document.getElementById(\"ingredientes\");\r\n  if (!ingredientesElement || !ingredientesElement.dataset.ingredientes) {\r\n    console.warn(\"[WARNING] No se encontraron ingredientes en el dataset.\");\r\n    return;\r\n  }\r\n\r\n  const ingredientes = JSON.parse(ingredientesElement.dataset.ingredientes || \"[]\");\r\n  console.log(\"[DEBUG] Ingredientes cargados:\", ingredientes);\r\n\r\n  let ingredientesTotalesHTML = \"\";\r\n\r\n  ingredientes.forEach(ingrediente => {\r\n    const inputPrecio = document.getElementById(`precio-${ingrediente.id}`);\r\n    \r\n    if (!inputPrecio) {\r\n      console.warn(`[WARNING] No se encontr√≥ el input para el ingrediente: ${ingrediente.name}`);\r\n      return;\r\n    }\r\n\r\n    // Obtener el precio unitario ingresado por el usuario\r\n    const precioUnitario = parseFloat(inputPrecio.value) || 0;\r\n    console.log(`[DEBUG] Precio de ${ingrediente.name}: ${precioUnitario} K`);\r\n\r\n    // üî• Calcular el costo total del ingrediente (precio unitario * cantidad requerida)\r\n    const costoIngrediente = precioUnitario * ingrediente.quantity;\r\n    gasto += costoIngrediente; // Sumar al gasto total de la receta\r\n\r\n    // Calcular cantidad total de ingredientes requeridos seg√∫n la cantidad a fabricar\r\n    const cantidadTotal = ingrediente.quantity * cantidadFabricar;\r\n    ingredientesTotalesHTML += `\r\n      <li>\r\n        <img src=\"${ingrediente.image}\" alt=\"${ingrediente.name}\" style=\"width: 40px; height: 40px; vertical-align: middle;\" />\r\n        ${ingrediente.name}: <strong>${cantidadTotal}</strong> unidades\r\n      </li>\r\n    `;\r\n  });\r\n\r\n  // üî• Calcular el Gasto Total multiplicando el gasto base por la cantidad a fabricar\r\n  const gastoTotal = gasto * cantidadFabricar;\r\n\r\n  // Verificar si el input del precio del objeto existe antes de obtener su valor\r\n  const precioObjetoInput = document.getElementById(\"precioObjeto\");\r\n  const precioObjeto = precioObjetoInput ? parseFloat(precioObjetoInput.value) || 0 : 0;\r\n\r\n  console.log(\"[DEBUG] Precio del objeto:\", precioObjeto);\r\n\r\n  // Calcular la ganancia correctamente\r\n  const ganancia = (precioObjeto * cantidadFabricar) - gastoTotal;\r\n\r\n  // ‚úÖ Actualizar el Gasto en la secci√≥n verde\r\n  const gastoElement = document.getElementById(\"gasto\");\r\n  if (gastoElement) gastoElement.textContent = `${gasto} K`;\r\n\r\n  // ‚úÖ Actualizar la Ganancia en la secci√≥n verde\r\n  const gananciaElement = document.getElementById(\"ganancia\");\r\n  if (gananciaElement) gananciaElement.textContent = `${ganancia} K`;\r\n\r\n  // ‚úÖ Actualizar la Ganancia Total en la secci√≥n azul\r\n  const gananciaTotalElement = document.getElementById(\"gananciaTotal\");\r\n  if (gananciaTotalElement) gananciaTotalElement.textContent = `${ganancia} K`;\r\n\r\n  // ‚úÖ Restaurar la actualizaci√≥n de \"Gasto Total\" en la secci√≥n azul\r\n  let gastoTotalElement = document.getElementById(\"gastoTotal\");\r\n  if (!gastoTotalElement) {\r\n    const calculationDetails = document.getElementById(\"calculationDetails\");\r\n    gastoTotalElement = document.createElement(\"h3\");\r\n    gastoTotalElement.id = \"gastoTotal\";\r\n    calculationDetails.appendChild(gastoTotalElement);\r\n  }\r\n  gastoTotalElement.textContent = `Gasto Total: ${gastoTotal} K`;\r\n\r\n  // Actualizar la lista de ingredientes totales necesarios\r\n  const ingredientesTotalesElement = document.getElementById(\"ingredientesTotales\");\r\n  if (ingredientesTotalesElement) ingredientesTotalesElement.innerHTML = ingredientesTotalesHTML;\r\n\r\n  console.log(\"[DEBUG] C√°lculo completado:\");\r\n  console.log(` - Gasto: ${gasto} K`);\r\n  console.log(` - Gasto Total: ${gastoTotal} K`);\r\n  console.log(` - Ganancia: ${ganancia} K`);\r\n\r\n  // ‚úÖ Sincronizar con el blog (solo si la funci√≥n est√° definida)\r\n  if (typeof sincronizarConBlog === 'function') {\r\n    sincronizarConBlog();\r\n  }\r\n}\r\n\r\n// Asegurar que la funci√≥n sea accesible globalmente\r\nwindow.calcularGanancia = calcularGanancia;\r\n",
      "render.js": "import { calcularGanancia } from './calculo.js';\r\n\r\n// Funci√≥n para renderizar listas de efectos\r\nexport const renderEffects = (effects) => {\r\n  if (!effects || effects.length === 0) {\r\n    return \"<li>Sin efectos disponibles</li>\";\r\n  }\r\n  return effects\r\n    .map(\r\n      (effect) =>\r\n        `<li>${effect.characteristic || \"Efecto desconocido\"}: ${effect.from || 0} a ${effect.to || 0}</li>`\r\n    )\r\n    .join(\"\");\r\n};\r\n\r\n// Funci√≥n para renderizar la receta en el frontend con inputs de precios\r\nexport const renderRecipe = (recipe) => {\r\n  if (!recipe || recipe.length === 0) {\r\n    return \"<li>Receta no disponible</li>\";\r\n  }\r\n\r\n  return recipe.map(ingredient => {\r\n    const inputId = `precio-${ingredient.id}`;\r\n    return `\r\n      <li>\r\n        <img src=\"${ingredient.image}\" alt=\"${ingredient.name}\" style=\"width: 40px; height: 40px; vertical-align: middle;\" />\r\n        ${ingredient.name} (Cantidad: ${ingredient.quantity || \"N/A\"})\r\n        <input type=\"number\" class=\"price-input\" id=\"${inputId}\" placeholder=\"Precio por unidad\">\r\n      </li>\r\n    `;\r\n  }).join(\"\");\r\n};\r\n\r\n// ‚úÖ Funci√≥n mejorada para asignar eventos de c√°lculo a los inputs despu√©s de renderizar la receta\r\nexport function asignarEventosCalculo() {\r\n  document.querySelectorAll(\".price-input\").forEach(input => {\r\n    input.removeEventListener(\"input\", calcularGanancia); // üî• Evita eventos duplicados\r\n    input.addEventListener(\"input\", () => {\r\n      console.log(`[DEBUG] Evento disparado en: ${input.id}`);\r\n      calcularGanancia();\r\n    });\r\n  });\r\n}\r\n"
    }
  },
  "src": {
    "routes": {
      "blogRoutes.js": "// src/routes/blogRoutes.js  \r\nconst express = require('express');  \r\nconst router = express.Router();  \r\nconst BlogPost = require('../models/BlogPost');  \r\nconst verificarToken = require('../middlewares/authMiddleware');  \r\n  \r\n// Obtener todos los posts (con filtros opcionales)  \r\nrouter.get('/posts', async (req, res) => {  \r\n  try {  \r\n    const { ordenarPor, filtroValor } = req.query;  \r\n    let query = {};  \r\n    let sort = {};  \r\n      \r\n    // Aplicar filtro por valor m√≠nimo si se especifica  \r\n    if (filtroValor) {  \r\n      query.valor = { $gte: parseInt(filtroValor) };  \r\n    }  \r\n      \r\n    // Aplicar ordenamiento  \r\n    if (ordenarPor === 'valor') {  \r\n      sort.valor = -1; // Descendente por valor  \r\n    } else if (ordenarPor === 'reciente') {  \r\n      sort.fechaActualizacion = -1; // Descendente por fecha de actualizaci√≥n  \r\n    } else {  \r\n      sort.fechaCreacion = -1; // Por defecto, los m√°s nuevos primero  \r\n    }  \r\n      \r\n    const posts = await BlogPost.find(query)  \r\n      .sort(sort)  \r\n      .populate('usuariosLike', 'username')  \r\n      .populate('comentarios.usuario', 'username');  \r\n        \r\n    res.json({ success: true, data: posts });  \r\n  } catch (error) {  \r\n    console.error('Error al obtener posts:', error);  \r\n    res.status(500).json({ success: false, error: 'Error al obtener los posts' });  \r\n  }  \r\n});  \r\n  \r\n// Crear nuevo post (requiere autenticaci√≥n)  \r\nrouter.post('/posts', verificarToken, async (req, res) => {  \r\n  try {  \r\n    const { nombre, descripcion, imagen, valor, ingredientes } = req.body;  \r\n      \r\n    const newPost = new BlogPost({  \r\n      nombre,  \r\n      descripcion,  \r\n      imagen,  \r\n      valor,  \r\n      ingredientes  \r\n    });  \r\n      \r\n    await newPost.save();  \r\n    res.status(201).json({ success: true, data: newPost });  \r\n  } catch (error) {  \r\n    console.error('Error al crear post:', error);  \r\n    res.status(500).json({ success: false, error: 'Error al crear el post' });  \r\n  }  \r\n});  \r\n  \r\n// Dar like a un post  \r\nrouter.post('/posts/:id/like', verificarToken, async (req, res) => {  \r\n  try {  \r\n    const post = await BlogPost.findById(req.params.id);  \r\n    if (!post) {  \r\n      return res.status(404).json({ success: false, error: 'Post no encontrado' });  \r\n    }  \r\n      \r\n    // Verificar si el usuario ya dio like  \r\n    const userIndex = post.usuariosLike.indexOf(req.user.id);  \r\n      \r\n    if (userIndex === -1) {  \r\n      // A√±adir like  \r\n      post.likes += 1;  \r\n      post.usuariosLike.push(req.user.id);  \r\n    } else {  \r\n      // Quitar like  \r\n      post.likes -= 1;  \r\n      post.usuariosLike.splice(userIndex, 1);  \r\n    }  \r\n      \r\n    await post.save();  \r\n    res.json({ success: true, data: post });  \r\n  } catch (error) {  \r\n    console.error('Error al procesar like:', error);  \r\n    res.status(500).json({ success: false, error: 'Error al procesar el like' });  \r\n  }  \r\n});  \r\n  \r\n// A√±adir comentario  \r\nrouter.post('/posts/:id/comentario', verificarToken, async (req, res) => {  \r\n  try {  \r\n    const { texto } = req.body;  \r\n      \r\n    if (!texto) {  \r\n      return res.status(400).json({ success: false, error: 'El comentario no puede estar vac√≠o' });  \r\n    }  \r\n      \r\n    const post = await BlogPost.findById(req.params.id);  \r\n    if (!post) {  \r\n      return res.status(404).json({ success: false, error: 'Post no encontrado' });  \r\n    }  \r\n      \r\n    post.comentarios.push({  \r\n      usuario: req.user.id,  \r\n      texto  \r\n    });  \r\n      \r\n    await post.save();  \r\n      \r\n    // Obtener el post actualizado con los datos de usuario en comentarios  \r\n    const updatedPost = await BlogPost.findById(req.params.id)  \r\n      .populate('comentarios.usuario', 'username');  \r\n        \r\n    res.json({ success: true, data: updatedPost });  \r\n  } catch (error) {  \r\n    console.error('Error al a√±adir comentario:', error);  \r\n    res.status(500).json({ success: false, error: 'Error al a√±adir el comentario' });  \r\n  }  \r\n});  \r\n  \r\n// Crear o actualizar autom√°ticamente un post desde el buscador (sin autenticaci√≥n)\r\nrouter.post('/posts/updateOrCreate', async (req, res) => {\r\n  try {\r\n    console.log('[DEBUG] Petici√≥n recibida en updateOrCreate:', req.body);\r\n    const { nombre, descripcion, imagen, valor, ingredientes } = req.body;\r\n\r\n    if (!nombre || !valor) {\r\n      return res.status(400).json({ success: false, error: 'Faltan campos requeridos' });\r\n    }\r\n\r\n    // üî• Siempre eliminar versiones anteriores del objeto antes de crear uno nuevo\r\n    const eliminados = await BlogPost.deleteMany({ nombre });\r\n    console.log(`[INFO] Se eliminaron ${eliminados.deletedCount} versiones anteriores de \"${nombre}\"`);\r\n\r\n    const nuevoPost = new BlogPost({\r\n      nombre,\r\n      descripcion,\r\n      imagen,\r\n      valor,\r\n      ingredientes,\r\n      fechaCreacion: new Date(),\r\n      fechaActualizacion: new Date()\r\n    });\r\n\r\n    await nuevoPost.save();\r\n    return res.status(201).json({ success: true, mensaje: 'Versi√≥n actualizada del objeto agregada al blog' });\r\n\r\n  } catch (error) {\r\n    console.error('Error en updateOrCreate:', error);\r\n    return res.status(500).json({ success: false, error: 'Error interno del servidor' });\r\n  }\r\n});\r\n\r\n\r\nmodule.exports = router;"
    }
  }
}